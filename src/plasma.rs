//! A module for generating animated plasma effects with various patterns and color palettes.
//!
//! This module provides functionality to create smooth, colorful plasma animations using
//! different geometric patterns (ripples, spirals, circles, etc.) and color schemes.
//! The plasma effect is generated by combining mathematical functions with color
//! transformations to create fluid, psychedelic patterns.
//!
//! # Example
//! ```
//! use plasma::{Plasma, Shape, Palette};
//!
//! let plasma = Plasma::new(800, 600, Shape::Ripple, Palette::Rainbow);
//! let mut buffer = vec![0u32; 800 * 600];
//! plasma.draw(&mut buffer, 0.0);
//! ```
use clap::ValueEnum;

/// Defines the available shape patterns for the plasma effect
#[derive(Debug, PartialEq, Clone, ValueEnum)]
pub enum Shape {
    Ripple,
    Spiral,
    Circle,
    Square,
    Checkerboard,
}

/// Available color palettes for rendering the plasma effect
#[derive(Debug, PartialEq, Clone, ValueEnum)]
pub enum Palette {
    Rainbow,
    BlueCyan,
    Hot,
    PurplePink,
    BlackWhite,
}

/// A plasma effect generator that creates colorful animated patterns
pub struct Plasma {
    /// Width of the plasma effect in pixels
    width: usize,
    /// Height of the plasma effect in pixels  
    height: usize,
    /// The geometric shape used to generate the plasma pattern
    shape: Shape,
    /// Color palette used for rendering the plasma effect
    palette: Palette,
    /// Scale factor that controls the density/size of the plasma patterns
    scale: f32,
}

impl Plasma {
    pub fn new(width: usize, height: usize, shape: Shape, palette: Palette, scale: f32) -> Self {
        Self {
            width,
            height,
            shape,
            palette,
            scale,
        }
    }

    fn ripple(&self, dist: f32, time: f32) -> f32 {
        // Ripple pattern: sin(dist * 10.0 - time * 2.0)
        (dist * self.scale - time * 2.0).sin()
    }

    fn spiral(&self, dist: f32, time: f32, angle: f32) -> f32 {
        // Spiral pattern: sin(dist * 10.0 + angle * 3.0 + time)
        (dist * self.scale + angle * 3.0 + time).sin()
    }

    fn circle(&self, dist: f32, time: f32, angle: f32) -> f32 {
        // Circle pattern: sin(dist * 10.0 + time) + sin(angle * 2.0 + time)
        (dist * self.scale + time).sin() + (angle * 2.0 + time).sin()
    }

    fn square(&self, px: f32, py: f32, min_dim: f32, time: f32) -> f32 {
        // Square pattern: sin(px / min_dim * 10.0 + time) * sin(py / min_dim * 10.0 + time)
        ((px / min_dim) * self.scale + time).sin() * ((py / min_dim) * self.scale + time).sin()
    }

    fn checkerboard(&self, px: f32, py: f32, min_dim: f32, time: f32) -> f32 {
        // Checkerboard pattern: sin(px / min_dim * 10.0) * sin(py / min_dim * 10.0)
        //                       + sin((px / min_dim + time) * 5.0) * sin((py / min_dim + time) * 5.0)
        let scaled_x = (px / min_dim) * self.scale;
        let scaled_y = (py / min_dim) * self.scale;
        (scaled_x + time).sin() * (scaled_y + time).sin()
    }

    /// Converts HSV (Hue, Saturation, Value) color values to RGB (Red, Green, Blue)
    ///
    /// # Arguments
    ///
    /// * `h` - Hue angle in degrees [0, 360)
    /// * `s` - Saturation value [0, 1]
    /// * `v` - Value/brightness [0, 1]
    ///
    /// # Returns
    ///
    /// A tuple of (red, green, blue) values as 8-bit unsigned integers [0, 255]
    fn hsv_to_rgb(&self, h: f32, s: f32, v: f32) -> (u8, u8, u8) {
        // Normalize hue to [0,360) degree range
        let h = h % 360.0;
        // Calculate chroma (color intensity) from value and saturation
        let c = v * s;
        // Convert hue to sector position (60Â° per sector)
        let h_prime = h / 60.0;
        // Calculate intermediate value for RGB conversion based on hue position
        let x = c * (1.0 - ((h_prime % 2.0) - 1.0).abs());
        // Calculate value adjustment to maintain brightness level
        let m = v - c;

        let (r, g, b) = match h_prime as u8 {
            0 => (c, x, 0.0), // Red to Yellow: R constant, G increasing
            1 => (x, c, 0.0), // Yellow to Green: R decreasing, G constant
            2 => (0.0, c, x), // Green to Cyan: G constant, B increasing
            3 => (0.0, x, c), // Cyan to Blue: G decreasing, B constant
            4 => (x, 0.0, c), // Blue to Magenta: B constant, R increasing
            5 => (c, 0.0, x), // Magenta to Red: R constant, B decreasing
            _ => (c, 0.0, x), // Fallback case (should not occur with normalized input)
        };

        (
            (r + m).mul_add(255.0, 0.5) as u8,
            (g + m).mul_add(255.0, 0.5) as u8,
            (b + m).mul_add(255.0, 0.5) as u8,
        )
    }

    /// Renders the plasma effect into the provided pixel buffer.
    ///
    /// # Arguments
    /// * `buffer` - Mutable slice of u32 values representing the pixel buffer
    /// * `time` - Current time value in seconds, used for animation
    ///
    /// Each pixel in the buffer is updated with a color value based on the current
    /// shape, palette, and time parameters. The color values are packed into 32-bit
    /// ARGB format.
    pub fn draw(&self, buffer: &mut [u32], time: f32) {
        let w = self.width as f32;
        let h = self.height as f32;
        // Calculate the center coordinates of the display area
        let center_x = w * 0.5;
        let center_y = h * 0.5;
        // Calculate half of the smallest dimension for scaling patterns
        let min_dim = w.min(h) * 0.5;
        // Create alpha channel mask for ARGB color format (fully opaque)
        let alpha = 255 << 24;

        buffer
            .chunks_exact_mut(self.width)
            .enumerate()
            .for_each(|(y, row)| {
                // Calculate the y-coordinate relative to the center of the display
                let py = y as f32 - center_y;

                row.iter_mut().enumerate().for_each(|(x, pixel)| {
                    // Calculate the x-coordinate relative to the center of the display
                    let px = x as f32 - center_x;
                    // Calculate the normalized distance from the center point
                    let dist = (px * px + py * py).sqrt() / min_dim;
                    // Calculate the angle in radians from the center point
                    let angle = py.atan2(px);

                    let v = match self.shape {
                        Shape::Ripple => self.ripple(dist, time),
                        Shape::Spiral => self.spiral(dist, time, angle),
                        Shape::Circle => self.circle(dist, time, angle),
                        Shape::Square => self.square(px, py, min_dim, time),
                        Shape::Checkerboard => self.checkerboard(px, py, min_dim, time),
                    };
                    // Normalize the plasma value from [-1,1] to [0,1] range for color mapping
                    let v = v * 0.5 + 0.5;

                    let (r, g, b) = match self.palette {
                        Palette::Rainbow => self.hsv_to_rgb(v * 360.0, 1.0, 1.0),
                        Palette::BlueCyan => self.hsv_to_rgb(v * 120.0 + 180.0, 0.8, 1.0),
                        Palette::Hot => self.hsv_to_rgb(v * 60.0, 1.0, 1.0),
                        Palette::PurplePink => self.hsv_to_rgb(v * 60.0 + 270.0, 0.7, 1.0),
                        Palette::BlackWhite => {
                            let gray = (v * 255.0) as u8;
                            (gray, gray, gray)
                        }
                    };
                    *pixel = alpha | ((r as u32) << 16) | ((g as u32) << 8) | (b as u32);
                });
            });
    }
}
